// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.1
// source: notification.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire'
import { Struct } from './google/protobuf/struct'

export const protobufPackage = 'notification'

export interface SendNotificationToUserRequest {
  userId: number
  payload: { [key: string]: any } | undefined
}

export interface SendNotificationToUserResponse {
  result: { [key: string]: any } | undefined
}

function createBaseSendNotificationToUserRequest(): SendNotificationToUserRequest {
  return { userId: 0, payload: undefined }
}

export const SendNotificationToUserRequest: MessageFns<SendNotificationToUserRequest> = {
  encode(
    message: SendNotificationToUserRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).int32(message.userId)
    }
    if (message.payload !== undefined) {
      Struct.encode(Struct.wrap(message.payload), writer.uint32(18).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendNotificationToUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    const end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseSendNotificationToUserRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break
          }

          message.userId = reader.int32()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.payload = Struct.unwrap(Struct.decode(reader, reader.uint32()))
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): SendNotificationToUserRequest {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      payload: isObject(object.payload) ? object.payload : undefined,
    }
  },

  toJSON(message: SendNotificationToUserRequest): unknown {
    const obj: any = {}
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId)
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload
    }
    return obj
  },

  create<I extends Exact<DeepPartial<SendNotificationToUserRequest>, I>>(
    base?: I
  ): SendNotificationToUserRequest {
    return SendNotificationToUserRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<SendNotificationToUserRequest>, I>>(
    object: I
  ): SendNotificationToUserRequest {
    const message = createBaseSendNotificationToUserRequest()
    message.userId = object.userId ?? 0
    message.payload = object.payload ?? undefined
    return message
  },
}

function createBaseSendNotificationToUserResponse(): SendNotificationToUserResponse {
  return { result: undefined }
}

export const SendNotificationToUserResponse: MessageFns<SendNotificationToUserResponse> = {
  encode(
    message: SendNotificationToUserResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.result !== undefined) {
      Struct.encode(Struct.wrap(message.result), writer.uint32(10).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendNotificationToUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    const end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseSendNotificationToUserResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.result = Struct.unwrap(Struct.decode(reader, reader.uint32()))
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): SendNotificationToUserResponse {
    return { result: isObject(object.result) ? object.result : undefined }
  },

  toJSON(message: SendNotificationToUserResponse): unknown {
    const obj: any = {}
    if (message.result !== undefined) {
      obj.result = message.result
    }
    return obj
  },

  create<I extends Exact<DeepPartial<SendNotificationToUserResponse>, I>>(
    base?: I
  ): SendNotificationToUserResponse {
    return SendNotificationToUserResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<SendNotificationToUserResponse>, I>>(
    object: I
  ): SendNotificationToUserResponse {
    const message = createBaseSendNotificationToUserResponse()
    message.result = object.result ?? undefined
    return message
  },
}

export interface NotificationService {
  SendNotificationToUser(
    request: SendNotificationToUserRequest
  ): Promise<SendNotificationToUserResponse>
}

export const NotificationServiceServiceName = 'notification.NotificationService'
export class NotificationServiceClientImpl implements NotificationService {
  private readonly rpc: Rpc
  private readonly service: string
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || NotificationServiceServiceName
    this.rpc = rpc
    this.SendNotificationToUser = this.SendNotificationToUser.bind(this)
  }
  SendNotificationToUser(
    request: SendNotificationToUserRequest
  ): Promise<SendNotificationToUserResponse> {
    const data = SendNotificationToUserRequest.encode(request).finish()
    const promise = this.rpc.request(this.service, 'SendNotificationToUser', data)
    return promise.then((data) => SendNotificationToUserResponse.decode(new BinaryReader(data)))
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never }

function isObject(value: any): boolean {
  return typeof value === 'object' && value !== null
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter
  decode(input: BinaryReader | Uint8Array, length?: number): T
  fromJSON(object: any): T
  toJSON(message: T): unknown
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
